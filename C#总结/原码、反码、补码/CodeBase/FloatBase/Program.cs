/*
 *   浮点数 float double 
 *      float二进制表示 32位
 *          符号位(最高位1位)阶码位(8位)底数位(23位)
 *          阶码为了便于计算，都加上 127
 *          结论：1、内存中直接存储浮点数的二进制表示，不管正负都    不需要转成补码
 *               2、因为存在乘不尽的小数，所以才存在精度误差
 *      double 二进制表示 64位
 *          符号位(最高位1位)阶码位(11位)底数位(52位)
 *          阶码为了便于计算，都加上 1023
 *          和float一样
 */
using System;

namespace FloatBase
{
    class Program
    {
        static void Main(string[] args)
        {
            //ComfirmFloat();
            ComfirmDouble();
            Console.Read();
        }

        private static void ComfirmFloat()
        {
            Console.WriteLine("----------浮点数float----------");
            Console.WriteLine("------整数------");
            // 正数
            float fplus = 13.0625f;
            // 计算浮点数的二进制表示
            // 步骤1、
            //      整数部分 13 = 1101
            //      小数部分 0.0625 * 2 = 0.125  ----取正数部分  0
            //               0.125 * 2 = 0.25   ----取整数部分  0
            //               0.25  * 2 = 0.5    ----取整数部分  0
            //               0.5   * 2 = 1.0    ----取整数部分  1        ----判断小数部分为0，结束计算
            //      最后小数的二进制表示  0001
            //      浮点数的二进制表示可以写成 "1101.0001"
            // 步骤2、
            //      计算阶码和底数
            //      "1101.0001" ，需要使最左侧是一位整数1 ，所以小数点需要左移3位，得到 "1.1010001"  ---- 阶码公式(左移是正，右移是负)：127 + (+3) = 130 二进制表示  10000010
            //      底数：由于每一个底数的最左侧都是整数1，所以为了节省空间，就不存储，得到底数是 1010001，然后右侧补零至23位 1010001 0000 0000 0000 0000
            // 步骤3、
            //      判断符号位 正为0 负为1
            // 步骤4、
            //      最终写法： 0 10000010 10100010000000000000000 
            //      标准写法   0100 0001 0101 0001 0000 0000 0000 0000   16进制表示 0x41510000
            // 指针验证
            unsafe
            {
                float* p1 = &fplus;
                byte* b1 = (byte*)p1;
                for (int i = 0; i < sizeof(float); i++)
                {
                    Console.WriteLine("Address  {0}, Value  {1:X}", (int)b1, *b1);
                    b1++;
                }
            }

            // 将二进制浮点数转换成10进制表示，就是上述的反过程
            // 步骤1、
            //      分离 符号位 阶码 底数
            // 符号位 0
            // 阶码  10000010
            // 底数  10100010000000000000000
            // 步骤2、
            //      计算阶码，确定移动位数
            //  10000010  作为无符号数 -- 130， 130-127 = 3 说明底数需要右移3个小数点
            // 步骤3、
            //      计算底数
            // 还原真正的底数(头部添加1，之前省去的) 1.10100010000000000000000 --->然后小数点右移3位，并且把多余的0去掉 1101.0001
            // 步骤4
            //      计算整数和小数
            // 整数: 1110  = 1*2^3 + 1*2^2 + 1*2^1 = 13
            // 小数: 0001 = 1*2^-4 = 0.0625
            // 整体：13.0625
            // 步骤5
            //      添加符号位 0 :正，最后的结果 13.0625

            Console.WriteLine("------负数------");
            // 负数
            float fmins = -0.425f;
            // 计算浮点数的二进制表示
            // 步骤1、
            //      整数部分 0 = 0
            //      小数部分 0.425 * 2 = 0.85   ----取正数部分  0
            //               0.85 * 2 =  1.7   ----取整数部分  1
            //               0.7  * 2 =  1.4   ----取整数部分  1
            //               0.4   * 2 = 0.8   ----取整数部分  0        
            //               0.8   * 2 = 1.6   ----取整数部分  1
            //               0.6   * 2 = 1.2   ----取整数部分  1
            //               0.2   * 2 = 0.4   ----取整数部分  0
            //               0.4   * 2 = 0.8   ----取整数部分  0     --- 乘不尽，从这步开始循环
            //      最后小数的二进制表示  011 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 ......
            //      浮点数的二进制表示可以写成 "0.011 0110 0110 0110 0110 0110 0110 0110 0110 0110 ......"
            // 步骤2、
            //      计算阶码和底数
            //      整数和小数二进制表示，需要使最左侧是一位整数1 ，所以小数点需要右移2位，得到 "1.1 0110 0110 0110 0110 0110 0110 0110 0110 0110 ......"  ---- 阶码公式(左移是正，右移是负)：127 + (-2) = 125 二进制表示  0111 1101
            //      底数：由于每一个底数的最左侧都是整数1，所以为了节省空间，就不存储，得到底数是 1 0110 0110 0110 0110 0110 0110 0110 0110 0110 ......，然后右侧截取23位 1 0110 0110 0110 0110 0110 01(10) 右侧为1，需要进位，最终 1 0110 0110 0110 0110 0110 10
            // 步骤3、
            //      判断符号位 正为0 负为1
            // 步骤4、
            //      最终写法： 1 01111101 1 0110 0110 0110 0110 0110 10
            //      标准写法   1011 1110 1101 1001 1001 1001 1001 1010   16进制表示 0xBED9999A
            // 指针验证
            unsafe
            {
                float* p1 = &fmins;
                byte* b1 = (byte*)p1;
                for (int i = 0; i < sizeof(float); i++)
                {
                    Console.WriteLine("Address  {0}, Value  {1:X}", (int)b1, *b1);
                    b1++;
                }
            }
        }

        private static void ComfirmDouble()
        {
            // 正数
            double dplus = 13.0625;
            // 计算浮点数的二进制表示
            // 步骤1、
            //      整数部分 13 = 1101
            //      小数部分 0.0625 * 2 = 0.125  ----取正数部分  0
            //               0.125 * 2 = 0.25   ----取整数部分  0
            //               0.25  * 2 = 0.5    ----取整数部分  0
            //               0.5   * 2 = 1.0    ----取整数部分  1        ----判断小数部分为0，结束计算
            //      最后小数的二进制表示  0001
            //      浮点数的二进制表示可以写成 "1101.0001"
            // 步骤2、
            //      计算阶码(11位)和底数
            //      "1101.0001" ，需要使最左侧是一位整数1 ，所以小数点需要左移3位，得到 "1.1010001"  ---- 阶码公式(左移是正，右移是负)：1023 + (+3) = 1026 二进制表示 100 0000 0010 
            //      底数：由于每一个底数的最左侧都是整数1，所以为了节省空间，就不存储，得到底数是 1010001，然后右侧补零至52位 1010001 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0
            // 步骤3、
            //      判断符号位 正为0 负为1
            // 步骤4、
            //      最终写法： 0 10000000010 1010001 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0
            //      标准写法   0100 0000 0010 1010 0010 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000   16进制表示 0x402A200000000000
            // 指针验证
            unsafe
            {
                double* p1 = &dplus;
                byte* b1 = (byte*)p1;
                for (int i = 0; i < sizeof(double); i++)
                {
                    Console.WriteLine("Address  {0}, Value  {1:X}", (int)b1, *b1);
                    b1++;
                }
            }
            // 计算浮点数的二进制表示 1.0
            // 步骤1、
            //      整数部分 1 = 0001
            //      小数部分 0.0625 * 2 = 0.125  ----取正数部分  0
            //               0.125 * 2 = 0.25   ----取整数部分  0
            //               0.25  * 2 = 0.5    ----取整数部分  0
            //               0.5   * 2 = 1.0    ----取整数部分  1        ----判断小数部分为0，结束计算
            //      最后小数的二进制表示  0
            //      浮点数的二进制表示可以写成 "0001.0"
            // 步骤2、
            //      计算阶码和底数
            //      "1101.0001" ，需要使最左侧是一位整数1 ，所以小数点需要左移3位，得到 "1.1010001"  ---- 阶码公式(左移是正，右移是负)：1023 + (+3) = 1026 二进制表示 011 1111 1111
            //      底数：由于每一个底数的最左侧都是整数1，所以为了节省空间，就不存储，得到底数是 1010001，然后右侧补零至52位 1010001 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0
            // 步骤3、
            //      判断符号位 正为0 负为1
            // 步骤4、
            //      最终写法： 1011 1111 1111 000 = BFF000
            //      INT 的 补码
            //           原码  1100 0000 0001 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
            //      标准写法   0100 0000 0010 1010 0010 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000   16进制表示 0x402A200000000000
        }

    }
}
